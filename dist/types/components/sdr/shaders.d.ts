export declare const SPECTRUM_FILL_VS = "#version 300 es\nuniform sampler2D u_data; // Nx1 texture\nuniform float u_bins;\nuniform float u_minDb;\nuniform float u_maxDb;\n\nout float v_yNorm; // For gradient\n\nvoid main() {\n  int id = gl_VertexID;\n  int binIndex = id / 2;\n  bool isTop = (id % 2) == 0;\n\n  // Fetch magnitude (using texelFetch for exact pixel)\n  float mag = texelFetch(u_data, ivec2(binIndex, 0), 0).r;\n  \n  // Normalize Y: (mag - min) / span\n  float yNorm = (mag - u_minDb) / (u_maxDb - u_minDb);\n  \n  // If bottom vertex, force Y to min (0.0 normalized)\n  if (!isTop) {\n     yNorm = 0.0;\n  }\n  \n  v_yNorm = yNorm; // Pass to FS for gradient\n\n  // X coordinate: -1..1\n  float x = (float(binIndex) / (u_bins - 1.0)) * 2.0 - 1.0;\n  // Y coordinate: -1..1\n  float y = yNorm * 2.0 - 1.0;\n\n  gl_Position = vec4(x, y, 0.0, 1.0);\n}\n";
export declare const SPECTRUM_FILL_FS = "#version 300 es\nprecision mediump float;\nin float v_yNorm;\nout vec4 outColor;\n\nvoid main() {\n  // Gradient from Dark Blue (bottom) to Light Blue (top)\n  vec4 colorBottom = vec4(0.0, 0.1, 0.3, 0.6); // Dark semi-transparent\n  vec4 colorTop = vec4(0.0, 0.6, 1.0, 0.9);    // Brighter Light Blue\n  \n  outColor = mix(colorBottom, colorTop, v_yNorm);\n}\n";
export declare const SPECTRUM_LINE_VS = "#version 300 es\nuniform sampler2D u_data;\nuniform float u_bins;\nuniform float u_minDb;\nuniform float u_maxDb;\n\nvoid main() {\n  int binIndex = gl_VertexID;\n  float mag = texelFetch(u_data, ivec2(binIndex, 0), 0).r;\n  \n  float yNorm = (mag - u_minDb) / (u_maxDb - u_minDb);\n  \n  float x = (float(binIndex) / (u_bins - 1.0)) * 2.0 - 1.0;\n  float y = yNorm * 2.0 - 1.0;\n\n  gl_Position = vec4(x, y, 0.0, 1.0);\n}\n";
export declare const SPECTRUM_VS = "#version 300 es\nuniform sampler2D u_data;\nuniform float u_bins;\nuniform float u_minDb;\nuniform float u_maxDb;\n\nvoid main() {\n  int binIndex = gl_VertexID;\n  float mag = texelFetch(u_data, ivec2(binIndex, 0), 0).r;\n  \n  float yNorm = (mag - u_minDb) / (u_maxDb - u_minDb);\n  \n  float x = (float(binIndex) / (u_bins - 1.0)) * 2.0 - 1.0;\n  float y = yNorm * 2.0 - 1.0;\n\n  gl_Position = vec4(x, y, 0.0, 1.0);\n}\n";
export declare const SPECTRUM_FS = "#version 300 es\nprecision mediump float;\nuniform vec4 u_color;\nout vec4 outColor;\n\nvoid main() {\n  outColor = vec4(1.0, 1.0, 1.0, 1.0); // Pure White Line\n}\n";
export declare const WATERFALL_VS = "#version 300 es\nin vec2 a_position; // quad vertices -1..1\nin vec2 a_texCoord; // 0..1\n\nout vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = vec4(a_position, 0.0, 1.0);\n  v_texCoord = a_texCoord;\n}\n";
export declare const WATERFALL_FS = "#version 300 es\nprecision mediump float;\n\nin vec2 v_texCoord;\nout vec4 outColor;\n\nuniform sampler2D u_waterfall;\nuniform sampler2D u_colormap;\nuniform float u_offset; // Normalize Y offset for scrolling (0..1)\nuniform float u_minDb;\nuniform float u_maxDb;\n\nvoid main() {\n  // Scroll Y\n  float y = fract(v_texCoord.y + u_offset);\n  \n  // Sample magnitude from waterfall texture (red channel or R float)\n  float mag = texture(u_waterfall, vec2(v_texCoord.x, y)).r;\n  \n  // Map dB to 0..1 for colormap lookup\n  float intensity = clamp((mag - u_minDb) / (u_maxDb - u_minDb), 0.0, 1.0);\n  \n  // Sample colormap\n  outColor = texture(u_colormap, vec2(intensity, 0.5));\n}\n";
